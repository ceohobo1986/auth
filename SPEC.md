# Auth Specification

This document contains the specification for authentication server API
and the authentication flow for game clients connecting to a game server.

## Terminology

- JWT: JSON Web Token as specified in IETF RFC 7519.
- JWK: JSON Web Key as specified in IETF RFC 7517.
- JWKS: JSON Web Key Set as specified in IETF RFC 7517.
- Client: The Veloren client and the agent the player interacts with.
- Game server: A service running the Veloren multiplayer server software.
- Authentication server: A trusted central service that stores account information.
- Passkey: A base64 encoded password hash.
- ID: A version 4 UUID.

## Algorithms

AES256-GCM is used for symmetric encryption and
Ed25519 is used for asymmetric encryption.
Argon2 is used for password hashing.

## JWT Types

### Reserved Claims

- `iss`: issuer
- `iat`: timestamp of issuance
- `nbf`: not before timestamp
- `exp`: expiry timestamp
- `sub`: subject

### 1: Client <-> Game Server Authentication

```
{
  iss: string,
  iat: i32,
  nbf: i32,
  exp: i32,
  sub: string,
  usr: string
}
```

`sub` here is the ID of the account that is logging in.
`usr` is the username of the account logging in.

No issuance payload.

## Authentication Server API

The authentication server exposes an API over HTTPS.

### State

The authentication server state comes in two parts.

First it must maintain a record of all accounts.
This data should be stored on persistent storage, preferably in a database.

The second kind of state is the keyring it uses to sign JWTs.
A keyring contains multiple keysets, each containing a public and private key.

This keyring is fine to store in-memory or in some otherwise volatile storage
as the JWTs the keys are used to sign are also volatile and eventually expire.

Each keyset is valid for signing up until 18 hours after it's creation
but it has to be kept in the keychain for 24 hours and sent with the `get_public_keychain` route.
This 6 hour interval is an arbitrary rollover period.

An authentication server may store and use more than one keyset valid for signing at any
point in time but there is no benefit to doing so. An ideal implementation has a keychain varying from one to two keysets
with only one of them being valid for signing at any point in time and the other keyset being in it's rollover period.

Each keyset must have an ID that can be used to identify it in the keyring. This ID should take the form of a version 4 UUID.

Keysets should be generated by a cryptographically secure pseudorandom number generator. The exact algorithm is
irrelevant as long as it passes the requirements outlined [here](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) and is considered secure by the general cryptography community.

### Routes

#### v1 get_public_keychain

- Type: GET
- Route: `/api/v1/get_public_keychain`
- Response:
  ```
  {
    jwk: JWK[]
  }
  ```

Fetch the current JWKS of the authenticaton server.
These keys need to be fetched in order to verify issued JWTs.

#### v1 issue_jwt

- Type: POST
- Route: `/api/v1/issue_jwt`
- Payload:
  ```
  {
    jwt_type: i32,
    username: string,
    passkey: string,
    ?payload: any
  }
  ```
- Response:
  ```
  {
    jwt: string,
    kid: string
  }
  ```

The JWT issued will have an expiration of 5 minutes from issuance
and a not before claim set to 5 seconds prior to the time of issuance to account for clock skew.

The `kid` parameter exists to identify the key
within a keychain for the purpose of key rollover.

The payload is optional and depends on the JWT type being issued.

#### v1 sign_up

- Type: POST
- Route: `/api/v1/sign_up`
- Payload:
  ```
  {
    username: string,
    passkey: string,
    email: string
  }
  ```
- Response:
  ```
  {
    id: string
  }
  ```

#### v1 username_to_id

- Type: GET
- Route: `/api/v1/username_to_id`
- Parameters: `username`
- Response:
  ```
  {
    id: string
  }
  ```

#### v1 id_to_username

- Type: GET
- Route: `/api/v1/id_to_username`
- Parameters: `id`
- Response:
  ```
  {
    username: string
  }
  ```
