# Auth Specification

This document contains the specification for authentication server API
and the authentication flow for game clients connecting to a game server.

## Terminology

- JWT: JSON Web Token as specified in IETF RFC 7519.
- JWK: JSON Web Key as specified in IETF RFC 7517.
- JWKS: JSON Web Key Set as specified in IETF RFC 7517.
- Client: The Veloren client and the agent the player interacts with.
- Game server: A service running the Veloren multiplayer server software.
- Authentication server: A trusted central service that stores account information.
- Passkey: A base64 encoded password hash.
- ID: A version 4 UUID.
- CSPRNG: cryptographically secure pseudorandom number generator.

## Algorithms

AES128-GCM is used for symmetric encryption between the client and game server.
AES-GCM-SIV is used for symmetric encryption of the login JWT.
Ed25519 is used for asymmetric encryption.
Argon2 is used for password hashing.
ECDH with Curve25519 is used for key exchange.

## JWT Types

### Reserved Claims

- `iss`: issuer
- `iat`: timestamp of issuance
- `nbf`: not before timestamp
- `exp`: expiry timestamp
- `sub`: subject

### 1: Client <-> Game Server Authentication

```
{
  iss: string,
  iat: integer,
  nbf: integer,
  exp: integer,
  sub: string,
  usr: string,
  cpk: string,
  sit: integer
}
```

- `sub` here is the ID of the account that is logging in.
- `usr` is the username of the account logging in.
- `cpk` is the JWK encoded client public key.
- `sit` is the epoch number of the game server keyring.

Payload:

```
{
  cpk: string,
  gpk: string,
  sit: integer,
  username: string,
  passkey: string
}
```

`cpk` is a JWK encoded client public key.
`gpk` is a JWK encoded game server public key.
`sit` is the epoch number of the game server keyring.

This JWT format is a bit special. The JWT is not signed but symmetrically
encrypted using a shared secret generated with `Truncate(HMAC-SHA3-256(ECDH(game_server_public, auth_server_private), salt))`.

Extra:

```
{
  iv: string,
  salt: string
}
```

`iv` is the base64 encoded AES128-GCM IV used for encrypting the JWT.
`salt` is the base64 encoded 256 bit salt used for HMAC key derivation.

## Authentication Server API

The authentication server exposes an API over HTTPS.

### State

The authentication server state comes in two parts.

First it must maintain a record of all accounts.
This data should be stored on persistent storage, preferably in a database.

The second kind of state is the keyring it uses to sign JWTs.
A keyring contains multiple keypairs, each containing a public and private key.

This keyring is fine to store in-memory or in some otherwise volatile storage
as the JWTs the keys are used to sign are also volatile and eventually expire.

Each keypair is valid for signing up until 18 hours after it's creation
but it has to be kept in the keychain for 24 hours and sent with the `get_public_keychain` route.
This 6 hour interval is an arbitrary rollover period.

An authentication server may store and use more than one keypair valid for signing at any
point in time but there is no benefit to doing so. An ideal implementation has a keychain varying from one to two keypairs
with only one of them being valid for signing at any point in time and the other keypair being in it's rollover period.

Each keypair must have an ID that can be used to identify it in the keyring.
This ID should take the form of a 32 bit signed integer and the value starts at 0
and is continously incremented for every generated keypair.

Keypairs should be generated by a cryptographically secure pseudorandom number generator. The exact algorithm is
irrelevant as long as it passes the requirements outlined [here](https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator) and is considered secure by the general cryptography community.

### Routes

#### v1 get_public_keychain

- Type: GET
- Route: `/api/v1/get_public_keychain`
- Response:
  ```
  {
    jwk: JWK[]
  }
  ```

Fetch the current JWKS of the authenticaton server.
These keys need to be fetched in order to verify issued JWTs.

#### v1 issue_jwt

- Type: POST
- Route: `/api/v1/issue_jwt`
- Payload:
  ```
  {
    jwt_type: integer,
    ?payload: any
  }
  ```
- Response:
  ```
  {
    jwt: string,
    kid: integer,
    ?extra: any
  }
  ```

The JWT issued will have an expiration of 5 minutes from issuance
and a not before claim set to 5 seconds prior to the time of issuance to account for clock skew.

The `kid` parameter exists to identify the key
within a keychain for the purpose of key rollover.

The payload is optional and depends on the JWT type being issued.

#### v1 sign_up

- Type: POST
- Route: `/api/v1/sign_up`
- Payload:
  ```
  {
    username: string,
    passkey: string,
    email: string
  }
  ```
- Response:
  ```
  {
    id: string
  }
  ```

#### v1 username_to_id

- Type: GET
- Route: `/api/v1/username_to_id`
- Parameters: `username`
- Response:
  ```
  {
    id: string
  }
  ```

#### v1 id_to_username

- Type: GET
- Route: `/api/v1/id_to_username`
- Parameters: `id`
- Response:
  ```
  {
    username: string
  }
  ```

## Game Server State

The game server, just like the auth server, needs to maintain a rotating JWKS with a size varying between one and two.
with a valid-for-use duration of 10 minutes and a keyring lifetime of 15 minutes.

These keys should be Curve25519 and generated by a cryptographically secure pseudorandom number generator
according to the earlier specification.

The key IDs are 32 bit signed integers, start from 0 and incremented with every generated keypair.

The keyring is associated with an epoch counter. For every sign in done, the epoch counter is incremented.
When the keypairs in the keyring are rotated, the epoch counter is reset to 0.

To provide replay protection, a table of UUIDs mapping to epoch counters is also needed.
This table should be cleared when the epoch counter is reset to 0.

## Client <-> Game Server Authentication

Establishing a secure connection between client and the game server
as well as authenticating the client to the game server is done using the series
of steps detailed below.

1. The client fetches the game server JWKS and picks the newest public key.
2. The client generates an ephemeral asymmetric keypair using a CSPRNG.
3. The client issues a JWT of type 1 using it's public key, username, passkey and the game server public key.
4. The client opens an unsecured connection with the game server and sends a message containing the following:
   * Auth server provided IV
   * Auth server provided salt
   * Auth server public key ID
   * Game server public key ID
   * JWT
5. The game server fetches the JWKS from the authentication server and finds the public key used to
   encrypt the JWT. If the JWKS does not contain the correct key id, the JWT is too old and must be rejected.
6. The game server performs `Truncate(HMAC-SHA3-256(ECDH(auth_server_public, game_server_private), salt))` to find the
   the shared secret used to encrypt the JWT.\
7. The game server decrypts the JWT using the shared secret.
   If decryption fails, abort with an invalid JWT error.
8. The game server generates a new AES128-GCM IV and a 256 bit salt, sends them to the client coupled with
    the id of the game server keypair being used and computes a second shared secret
    using `Truncate(HMAC-SHA3-256(ECDH(client_public, game_server_private), salt))`.
9. The client computes the second shared secret using `Truncate(HMAC-SHA3-256(ECDH(game_server_public, client_private), salt))`.
   If the client does not have the game server public key with a matching key id, refetch the game server JWKS.
   If it still does not contain a matching key, reset both parties to step 8.
10. All future messages are now secured using AES128-GCM with the second shared secret and IV as parameters.
